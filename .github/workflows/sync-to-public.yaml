name: Sync Branch to Public Repo

on:
  workflow_dispatch:
    inputs:
      target_branch_name:
        description: "Target branch name in public repo"
        required: true
        default: "v2.6"
      commit_message:
        description: "Commit message for the public repo"
        required: true
        default: "Sync branch v2.6"
      tag_name:
        description: "Tag to apply to the target branch"
        required: true
        default: "v2.6"

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      - name: Determine current branch
        id: get_branch
        run: |
          echo "source_branch_name=${GITHUB_REF#refs/heads/}" >> $GITHUB_ENV
        # Logs the branch name for reference
        env:
          source_branch_name: ${{ github.ref_name }}

      - name: Checkout source branch
        uses: actions/checkout@v4
        with:
          ref: ${{ env.source_branch_name }}

      - name: Add public repository as remote
        env:
          GITHUB_TOKEN: ${{ secrets.PUBLIC_REPO_PAT }}
        run: |
          git remote add public https://gmanepalli-mlabs:${{ secrets.PUBLIC_REPO_PAT }}@github.com/MovieLabs/test-OMC.git

      - name: Check if target branch exists in public repo
        id: check_branch
        run: |
          if git ls-remote --heads public ${{ inputs.target_branch_name }} | grep ${{ inputs.target_branch_name }}; then
            echo "exists=true" >> $GITHUB_ENV
          else
            echo "exists=false" >> $GITHUB_ENV
          fi

      - name: Handle non-existing target branch
        if: env.exists == 'false'
        run: |
          # Create a new orphan branch in the public repo
          git checkout --orphan ${{ inputs.target_branch_name }}
          git reset --hard
          git commit --allow-empty -m "Initialize branch ${{ inputs.target_branch_name }}"
          git push public ${{ inputs.target_branch_name }}

      - name: Generate single commit for target branch
        run: |
          # Fetch the target branch if it exists
          if [ "$env.exists" == "true" ]; then
            git fetch public ${{ inputs.target_branch_name }}:${{ inputs.target_branch_name }}
          fi

          # Perform a squash merge of changes from source branch
          git checkout ${{ inputs.target_branch_name }}
          git reset --soft $(git merge-base public/${{ inputs.target_branch_name }} HEAD)
          git add .
          git commit -m "${{ inputs.commit_message }}"

          # Push the squashed changes to the public repo
          git push public ${{ inputs.target_branch_name }}

      - name: Apply tag to target branch (if provided)
        if: ${{ inputs.tag_name != '' }}
        env:
          GITHUB_TOKEN: ${{ secrets.PUBLIC_REPO_PAT }}
        run: |
          # Fetch the latest state of the target branch
          git fetch public ${{ inputs.target_branch_name }}

          # Checkout the target branch
          git checkout ${{ inputs.target_branch_name }}

          # Create the tag locally
          git tag -f ${{ inputs.tag_name }}

          # Push the tag to the public repository
          git push public ${{ inputs.tag_name }} --force
